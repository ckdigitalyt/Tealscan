"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_src_lib_pdfParser_ts";
exports.ids = ["_ssr_src_lib_pdfParser_ts"];
exports.modules = {

/***/ "(ssr)/./src/lib/pdfParser.ts":
/*!******************************!*\
  !*** ./src/lib/pdfParser.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseCASFile: () => (/* binding */ parseCASFile)\n/* harmony export */ });\n/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist */ \"(ssr)/../node_modules/pdfjs-dist/build/pdf.mjs\");\n\n// Set worker source to match the installed pdfjs-dist version (4.10.38)\npdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc = \"https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs\";\n// Detailed logging helper\nconst log = {\n    info: (msg, data)=>{\n        console.log(`[PDF-PARSER] INFO: ${msg}`, data !== undefined ? data : \"\");\n    },\n    error: (msg, error)=>{\n        console.error(`[PDF-PARSER] ERROR: ${msg}`, error !== undefined ? error : \"\");\n        if (error?.stack) console.error(`[PDF-PARSER] Stack:`, error.stack);\n    },\n    debug: (msg, data)=>{\n        console.log(`[PDF-PARSER] DEBUG: ${msg}`, data !== undefined ? data : \"\");\n    },\n    warn: (msg, data)=>{\n        console.warn(`[PDF-PARSER] WARN: ${msg}`, data !== undefined ? data : \"\");\n    }\n};\nasync function extractTextFromPDF(file, password) {\n    log.info(\"Starting PDF text extraction\", {\n        fileName: file.name,\n        fileSize: file.size,\n        fileType: file.type\n    });\n    try {\n        log.debug(\"Converting file to ArrayBuffer...\");\n        const arrayBuffer = await file.arrayBuffer();\n        log.debug(\"ArrayBuffer created\", {\n            byteLength: arrayBuffer.byteLength\n        });\n        log.debug(\"PDF.js worker source:\", pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc);\n        log.info(\"Loading PDF document with password...\");\n        // PDF.js can accept password as string or Uint8Array\n        // Try with string first, then handle password callback for encrypted PDFs\n        const passwordStr = password || \"\";\n        log.debug(\"Preparing password for PDF.js\", {\n            hasPassword: passwordStr.length > 0\n        });\n        const loadingTask = pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            password: passwordStr\n        });\n        // Handle password-protected PDF - set callback to provide password if needed\n        let passwordAttempted = false;\n        loadingTask.onPassword = (updatePassword, reason)=>{\n            log.debug(\"PDF password callback triggered\", {\n                reason,\n                passwordAttempted\n            });\n            // Reason: 1 = user password, 2 = owner password\n            if (!passwordAttempted && passwordStr) {\n                passwordAttempted = true;\n                try {\n                    // Try updating with the provided password\n                    updatePassword(passwordStr);\n                } catch (err) {\n                    log.error(\"Error calling updatePassword\", err);\n                }\n            }\n        };\n        log.debug(\"PDF loading task created, awaiting promise...\");\n        const pdf = await loadingTask.promise;\n        log.info(\"PDF loaded successfully\", {\n            numPages: pdf.numPages\n        });\n        let fullText = \"\";\n        for(let i = 1; i <= pdf.numPages; i++){\n            log.debug(`Extracting text from page ${i}/${pdf.numPages}...`);\n            const page = await pdf.getPage(i);\n            const textContent = await page.getTextContent();\n            // Group text items by Y-coordinate to preserve line breaks\n            // PDF.js TextItem uses transform matrix: [scaleX, skewX, skewY, scaleY, translateX, translateY]\n            // transform[4] = x position, transform[5] = y position\n            const LINE_TOLERANCE = 2; // Group items within 2 pixels as same line\n            const lineGroups = {};\n            for (const item of textContent.items){\n                // Filter to only TextItem objects (not TextMarkedContent)\n                if (!(\"str\" in item)) continue;\n                if (item.str.trim() === \"\") continue;\n                // Extract coordinates from transform matrix\n                const transform = item.transform;\n                if (!transform || transform.length < 6) continue;\n                const x = transform[4]; // translateX\n                const y = transform[5]; // translateY\n                // Round Y coordinate with tolerance to group items on same line\n                const yKey = Math.round(y / LINE_TOLERANCE) * LINE_TOLERANCE;\n                if (!lineGroups[yKey]) {\n                    lineGroups[yKey] = [];\n                }\n                lineGroups[yKey].push({\n                    str: item.str,\n                    x\n                });\n            }\n            // Sort lines by Y-coordinate (descending, since PDF Y origin is bottom-left)\n            const sortedYs = Object.keys(lineGroups).map(Number).sort((a, b)=>b - a); // Higher Y = higher on page, so sort descending\n            // Build page text with proper line breaks\n            const lines = sortedYs.map((yKey)=>{\n                return lineGroups[yKey].sort((a, b)=>a.x - b.x) // Sort items left to right\n                .map((item)=>item.str).join(\" \");\n            });\n            const pageText = lines.join(\"\\n\");\n            fullText += pageText + \"\\n\";\n            log.debug(`Page ${i} extracted`, {\n                textLength: pageText.length,\n                lineCount: lines.length\n            });\n        }\n        log.info(\"PDF text extraction complete\", {\n            totalTextLength: fullText.length\n        });\n        return fullText;\n    } catch (error) {\n        log.error(\"PDF extraction failed\", error);\n        log.error(\"Error details\", {\n            name: error?.name,\n            message: error?.message,\n            code: error?.code\n        });\n        // More specific error messages based on PDF.js error types\n        if (error?.name === \"PasswordException\" || error?.message?.toLowerCase().includes(\"password\")) {\n            throw new Error(\"Incorrect password. Please check and try again.\");\n        } else if (error?.name === \"InvalidPDFException\" || error?.message?.includes(\"Invalid PDF\")) {\n            throw new Error(\"Invalid PDF file. Please upload a valid CAS PDF.\");\n        } else if (error?.message?.includes(\"worker\")) {\n            throw new Error(\"PDF processing failed. Please refresh and try again.\");\n        } else if (error?.message?.includes(\"encrypted\") || error?.message?.includes(\"Encrypted\")) {\n            throw new Error(\"Incorrect password. Please check and try again.\");\n        }\n        throw new Error(`Failed to extract PDF text: ${error?.message || \"Unknown error\"}`);\n    }\n}\nfunction isLikelyDate(numStr) {\n    const num = numStr.replace(/,/g, \"\");\n    if (num.length === 8 && /^\\d{8}$/.test(num)) {\n        const day = parseInt(num.substring(0, 2));\n        const month = parseInt(num.substring(2, 4));\n        if (day >= 1 && day <= 31 && month >= 1 && month <= 12) return true;\n    }\n    if (num.length > 10) return true;\n    return false;\n}\nfunction extractCurrencyValues(text) {\n    const values = [];\n    const patterns = [\n        /₹\\s*([\\d,]+(?:\\.\\d{1,2})?)/g,\n        /Rs\\.?\\s*([\\d,]+(?:\\.\\d{1,2})?)/gi,\n        /INR\\s*([\\d,]+(?:\\.\\d{1,2})?)/gi\n    ];\n    for (const pattern of patterns){\n        let match;\n        while((match = pattern.exec(text)) !== null){\n            const numStr = match[1].replace(/,/g, \"\");\n            if (!isLikelyDate(numStr)) {\n                const value = parseFloat(numStr);\n                if (value > 0 && value < 100000000000) {\n                    values.push(value);\n                }\n            }\n        }\n    }\n    return values;\n}\nfunction parseCASText(text) {\n    const funds = [];\n    let totalValue = 0;\n    let totalInvested = 0;\n    log.debug(\"Starting CAS text parsing\");\n    const lines = text.split(/[\\n\\r]+/);\n    const fundsByName = {};\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        // Look for fund header lines: contains fund code + fund name + Direct/Growth/Dividend/Regular\n        // Example: \"101LCDGG - Canara Robeco Large Cap Fund - Direct Growth\"\n        // More flexible: no line-start anchor, allow multiple spaces and various separators\n        // Fund codes can start with numbers (e.g., 101LCDGG, 128SCDGG)\n        const fundHeaderMatch = line.match(/([A-Z0-9]{5,10})\\s*[-–]\\s*([A-Za-z0-9\\s\\-&()'.]+?)\\s*[-–—]\\s*(Direct|Regular|Growth|Dividend|DIRECT|REGULAR|GROWTH|DIVIDEND)/i);\n        if (fundHeaderMatch) {\n            const fundCode = fundHeaderMatch[1];\n            const fundName = fundHeaderMatch[2].trim().replace(/\\s+/g, \" \");\n            log.debug(\"Found fund header:\", {\n                fundCode,\n                fundName,\n                line: line.substring(0, 100)\n            });\n            // Look for ISIN and other details on next lines\n            let planType = \"Regular\";\n            let folio = \"N/A\";\n            let isin = \"\";\n            let amc = \"Unknown\";\n            // Search ahead for more details\n            for(let j = i + 1; j < Math.min(i + 10, lines.length); j++){\n                const detailLine = lines[j].trim();\n                // Look for plan type\n                if (/Direct|Regular|DIRECT|REGULAR/i.test(detailLine)) {\n                    const planMatch = detailLine.match(/(Direct|Regular|DIRECT|REGULAR)/i);\n                    if (planMatch) planType = planMatch[1].charAt(0).toUpperCase() + planMatch[1].slice(1).toLowerCase();\n                }\n                // Look for folio\n                const folioMatch = detailLine.match(/Folio\\s+(?:No)?[:\\s]*([A-Z0-9\\/\\-]+)/i);\n                if (folioMatch) folio = folioMatch[1].trim().substring(0, 25);\n                // Look for ISIN\n                const isinMatch = detailLine.match(/ISIN[:\\s]*([A-Z0-9\\s]+)/i);\n                if (isinMatch) isin = isinMatch[1].trim().substring(0, 15);\n                // Break if we hit next fund or transaction section\n                if (/[A-Z0-9]{5,10}\\s*[-–]\\s*[A-Za-z]/i.test(detailLine) || detailLine.match(/Date.*Amount.*Price/)) break;\n            }\n            // Extract AMC from fund name\n            const amcMatch = fundName.match(/(ICICI|HDFC|Axis|SBI|Motilal|Franklin|Kotak|DSP|L&T|Aditya|Nippon|JM|IDFC|Canara|LIC|UTI|Tata|Mahindra|Quantum|Invesco|PGIM|Mirae|Parag Parikh|PPFAS|Edelweiss|Sundaram)/i);\n            amc = amcMatch ? amcMatch[1] : \"Unknown\";\n            // Now search for Market Value and Cost Value for this fund\n            let marketValue = 0;\n            let costValue = 0;\n            for(let j = i; j < Math.min(i + 50, lines.length); j++){\n                const valueLine = lines[j].trim();\n                // Look for Market Value\n                const mvMatch = valueLine.match(/Market\\s+Value.*?INR\\s+([\\d,]+(?:\\.\\d{1,2})?)/i);\n                if (mvMatch) {\n                    marketValue = parseFloat(mvMatch[1].replace(/,/g, \"\"));\n                    log.debug(\"Found market value:\", {\n                        fundCode,\n                        marketValue\n                    });\n                }\n                // Look for Cost Value or Total Cost Value\n                const cvMatch = valueLine.match(/(?:Total\\s+)?Cost\\s+Value.*?INR?\\s*[:\\s]*([\\d,]+(?:\\.\\d{1,2})?)/i);\n                if (cvMatch) {\n                    costValue = parseFloat(cvMatch[1].replace(/,/g, \"\"));\n                    log.debug(\"Found cost value:\", {\n                        fundCode,\n                        costValue\n                    });\n                }\n                // Break if we hit next fund\n                if (j > i && /^[A-Z0-9]{5,8}\\s*-/i.test(valueLine)) break;\n            }\n            if (marketValue > 0 || costValue > 0) {\n                if (costValue === 0) costValue = marketValue;\n                if (marketValue === 0) marketValue = costValue;\n                log.debug(\"Adding fund from header:\", {\n                    fundCode,\n                    fundName,\n                    marketValue,\n                    costValue,\n                    planType\n                });\n                fundsByName[fundCode] = {\n                    name: fundName,\n                    folio,\n                    value: marketValue,\n                    invested: costValue,\n                    planType,\n                    amc\n                };\n            }\n        }\n    }\n    // Convert to array and sum totals\n    for(const fundCode in fundsByName){\n        const fund = fundsByName[fundCode];\n        if (fund.value > 0 || fund.invested > 0) {\n            funds.push(fund);\n            totalValue += fund.value;\n            totalInvested += fund.invested;\n        }\n    }\n    log.debug(\"Final parsed data:\", {\n        fundsCount: funds.length,\n        totalValue,\n        totalInvested,\n        funds: funds.map((f)=>({\n                name: f.name.substring(0, 30),\n                value: f.value,\n                invested: f.invested\n            }))\n    });\n    return {\n        funds,\n        totalValue,\n        totalInvested\n    };\n}\nasync function parseCASFile(file, password) {\n    log.info(\"=== Starting CAS file parsing ===\");\n    log.info(\"File details\", {\n        name: file.name,\n        size: file.size,\n        type: file.type\n    });\n    const startTime = performance.now();\n    try {\n        log.info(\"Step 1: Extracting text from PDF...\");\n        const text = await extractTextFromPDF(file, password);\n        log.info(\"Step 1 complete: Text extracted\", {\n            textLength: text.length\n        });\n        log.info(\"Step 2: Parsing CAS text for funds...\");\n        const data = parseCASText(text);\n        log.info(\"Step 2 complete: Text parsed\", {\n            fundsCount: data.funds.length,\n            totalValue: data.totalValue,\n            totalInvested: data.totalInvested\n        });\n        const endTime = performance.now();\n        const duration = (endTime - startTime).toFixed(0);\n        log.info(`=== Parsing complete in ${duration}ms ===`);\n        log.info(\"Results\", {\n            funds: data.funds.length,\n            totalValue: `₹${data.totalValue.toLocaleString(\"en-IN\")}`\n        });\n        if (data.funds.length === 0) {\n            log.warn(\"No funds found in parsed data\");\n            log.debug(\"First 1000 chars of extracted text:\", text.substring(0, 1000));\n            throw new Error(\"No funds found in CAS. Please check the file format and password.\");\n        }\n        return data;\n    } catch (error) {\n        const endTime = performance.now();\n        log.error(`=== Parsing failed after ${(endTime - startTime).toFixed(0)}ms ===`);\n        log.error(\"Error in parseCASFile\", error);\n        log.error(\"Error type\", {\n            name: error?.name,\n            message: error?.message,\n            isError: error instanceof Error\n        });\n        // Re-throw with proper error message\n        if (error instanceof Error) {\n            throw error;\n        }\n        throw new Error(\"Failed to parse CAS PDF. Please try again.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0csT0FBWTtRQUNuQixNQUFNeUgsVUFBVUYsWUFBWUMsR0FBRztRQUMvQjlILElBQUlNLEtBQUssQ0FBQyxDQUFDLHlCQUF5QixFQUFFLENBQUN5SCxVQUFVSCxTQUFRLEVBQUdLLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUM5RWpJLElBQUlNLEtBQUssQ0FBQyx5QkFBeUJBO1FBQ25DTixJQUFJTSxLQUFLLENBQUMsY0FBYztZQUN0QlEsTUFBTVIsT0FBT1E7WUFDYnFELFNBQVM3RCxPQUFPNkQ7WUFDaEJnRSxTQUFTN0gsaUJBQWlCaUU7UUFDNUI7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSWpFLGlCQUFpQmlFLE9BQU87WUFDMUIsTUFBTWpFO1FBQ1I7UUFDQSxNQUFNLElBQUlpRSxNQUFNO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL3NyYy9saWIvcGRmUGFyc2VyLnRzP2I1OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGRmanNMaWIgZnJvbSAncGRmanMtZGlzdCc7XG5cbi8vIFNldCB3b3JrZXIgc291cmNlIHRvIG1hdGNoIHRoZSBpbnN0YWxsZWQgcGRmanMtZGlzdCB2ZXJzaW9uICg0LjEwLjM4KVxucGRmanNMaWIuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSAnaHR0cHM6Ly91bnBrZy5jb20vcGRmanMtZGlzdEA0LjEwLjM4L2J1aWxkL3BkZi53b3JrZXIubWluLm1qcyc7XG5cbi8vIERldGFpbGVkIGxvZ2dpbmcgaGVscGVyXG5jb25zdCBsb2cgPSB7XG4gIGluZm86IChtc2c6IHN0cmluZywgZGF0YT86IGFueSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbUERGLVBBUlNFUl0gSU5GTzogJHttc2d9YCwgZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YSA6ICcnKTtcbiAgfSxcbiAgZXJyb3I6IChtc2c6IHN0cmluZywgZXJyb3I/OiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGBbUERGLVBBUlNFUl0gRVJST1I6ICR7bXNnfWAsIGVycm9yICE9PSB1bmRlZmluZWQgPyBlcnJvciA6ICcnKTtcbiAgICBpZiAoZXJyb3I/LnN0YWNrKSBjb25zb2xlLmVycm9yKGBbUERGLVBBUlNFUl0gU3RhY2s6YCwgZXJyb3Iuc3RhY2spO1xuICB9LFxuICBkZWJ1ZzogKG1zZzogc3RyaW5nLCBkYXRhPzogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coYFtQREYtUEFSU0VSXSBERUJVRzogJHttc2d9YCwgZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YSA6ICcnKTtcbiAgfSxcbiAgd2FybjogKG1zZzogc3RyaW5nLCBkYXRhPzogYW55KSA9PiB7XG4gICAgY29uc29sZS53YXJuKGBbUERGLVBBUlNFUl0gV0FSTjogJHttc2d9YCwgZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YSA6ICcnKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBFeHRyYWN0ZWRGdW5kIHtcbiAgbmFtZTogc3RyaW5nO1xuICBmb2xpbzogc3RyaW5nO1xuICB2YWx1ZTogbnVtYmVyO1xuICBpbnZlc3RlZDogbnVtYmVyO1xuICBwbGFuVHlwZTogc3RyaW5nO1xuICBhbWM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRDQVNEYXRhIHtcbiAgZnVuZHM6IEV4dHJhY3RlZEZ1bmRbXTtcbiAgdG90YWxWYWx1ZTogbnVtYmVyO1xuICB0b3RhbEludmVzdGVkOiBudW1iZXI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RUZXh0RnJvbVBERihmaWxlOiBGaWxlLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgbG9nLmluZm8oJ1N0YXJ0aW5nIFBERiB0ZXh0IGV4dHJhY3Rpb24nLCB7IGZpbGVOYW1lOiBmaWxlLm5hbWUsIGZpbGVTaXplOiBmaWxlLnNpemUsIGZpbGVUeXBlOiBmaWxlLnR5cGUgfSk7XG4gIFxuICB0cnkge1xuICAgIGxvZy5kZWJ1ZygnQ29udmVydGluZyBmaWxlIHRvIEFycmF5QnVmZmVyLi4uJyk7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XG4gICAgbG9nLmRlYnVnKCdBcnJheUJ1ZmZlciBjcmVhdGVkJywgeyBieXRlTGVuZ3RoOiBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIH0pO1xuICAgIFxuICAgIGxvZy5kZWJ1ZygnUERGLmpzIHdvcmtlciBzb3VyY2U6JywgcGRmanNMaWIuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMpO1xuICAgIGxvZy5pbmZvKCdMb2FkaW5nIFBERiBkb2N1bWVudCB3aXRoIHBhc3N3b3JkLi4uJyk7XG4gICAgXG4gICAgLy8gUERGLmpzIGNhbiBhY2NlcHQgcGFzc3dvcmQgYXMgc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAgICAvLyBUcnkgd2l0aCBzdHJpbmcgZmlyc3QsIHRoZW4gaGFuZGxlIHBhc3N3b3JkIGNhbGxiYWNrIGZvciBlbmNyeXB0ZWQgUERGc1xuICAgIGNvbnN0IHBhc3N3b3JkU3RyID0gcGFzc3dvcmQgfHwgJyc7XG4gICAgbG9nLmRlYnVnKCdQcmVwYXJpbmcgcGFzc3dvcmQgZm9yIFBERi5qcycsIHsgaGFzUGFzc3dvcmQ6IHBhc3N3b3JkU3RyLmxlbmd0aCA+IDAgfSk7XG4gICAgXG4gICAgY29uc3QgbG9hZGluZ1Rhc2sgPSBwZGZqc0xpYi5nZXREb2N1bWVudCh7XG4gICAgICBkYXRhOiBhcnJheUJ1ZmZlcixcbiAgICAgIHBhc3N3b3JkOiBwYXNzd29yZFN0cixcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgcGFzc3dvcmQtcHJvdGVjdGVkIFBERiAtIHNldCBjYWxsYmFjayB0byBwcm92aWRlIHBhc3N3b3JkIGlmIG5lZWRlZFxuICAgIGxldCBwYXNzd29yZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQgPSAodXBkYXRlUGFzc3dvcmQ6IEZ1bmN0aW9uLCByZWFzb246IG51bWJlcikgPT4ge1xuICAgICAgbG9nLmRlYnVnKCdQREYgcGFzc3dvcmQgY2FsbGJhY2sgdHJpZ2dlcmVkJywgeyByZWFzb24sIHBhc3N3b3JkQXR0ZW1wdGVkIH0pO1xuICAgICAgLy8gUmVhc29uOiAxID0gdXNlciBwYXNzd29yZCwgMiA9IG93bmVyIHBhc3N3b3JkXG4gICAgICBpZiAoIXBhc3N3b3JkQXR0ZW1wdGVkICYmIHBhc3N3b3JkU3RyKSB7XG4gICAgICAgIHBhc3N3b3JkQXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdXBkYXRpbmcgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3dvcmRcbiAgICAgICAgICB1cGRhdGVQYXNzd29yZChwYXNzd29yZFN0cik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcignRXJyb3IgY2FsbGluZyB1cGRhdGVQYXNzd29yZCcsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGxvZy5kZWJ1ZygnUERGIGxvYWRpbmcgdGFzayBjcmVhdGVkLCBhd2FpdGluZyBwcm9taXNlLi4uJyk7XG4gICAgY29uc3QgcGRmID0gYXdhaXQgbG9hZGluZ1Rhc2sucHJvbWlzZTtcbiAgICBsb2cuaW5mbygnUERGIGxvYWRlZCBzdWNjZXNzZnVsbHknLCB7IG51bVBhZ2VzOiBwZGYubnVtUGFnZXMgfSk7XG5cbiAgICBsZXQgZnVsbFRleHQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHBkZi5udW1QYWdlczsgaSsrKSB7XG4gICAgICBsb2cuZGVidWcoYEV4dHJhY3RpbmcgdGV4dCBmcm9tIHBhZ2UgJHtpfS8ke3BkZi5udW1QYWdlc30uLi5gKTtcbiAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBwZGYuZ2V0UGFnZShpKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gYXdhaXQgcGFnZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgXG4gICAgICAvLyBHcm91cCB0ZXh0IGl0ZW1zIGJ5IFktY29vcmRpbmF0ZSB0byBwcmVzZXJ2ZSBsaW5lIGJyZWFrc1xuICAgICAgLy8gUERGLmpzIFRleHRJdGVtIHVzZXMgdHJhbnNmb3JtIG1hdHJpeDogW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldXG4gICAgICAvLyB0cmFuc2Zvcm1bNF0gPSB4IHBvc2l0aW9uLCB0cmFuc2Zvcm1bNV0gPSB5IHBvc2l0aW9uXG4gICAgICBjb25zdCBMSU5FX1RPTEVSQU5DRSA9IDI7IC8vIEdyb3VwIGl0ZW1zIHdpdGhpbiAyIHBpeGVscyBhcyBzYW1lIGxpbmVcbiAgICAgIGNvbnN0IGxpbmVHcm91cHM6IHsgW2tleTogbnVtYmVyXTogQXJyYXk8e3N0cjogc3RyaW5nLCB4OiBudW1iZXJ9PiB9ID0ge307XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0ZXh0Q29udGVudC5pdGVtcykge1xuICAgICAgICAvLyBGaWx0ZXIgdG8gb25seSBUZXh0SXRlbSBvYmplY3RzIChub3QgVGV4dE1hcmtlZENvbnRlbnQpXG4gICAgICAgIGlmICghKCdzdHInIGluIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGl0ZW0uc3RyLnRyaW0oKSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gRXh0cmFjdCBjb29yZGluYXRlcyBmcm9tIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gKGl0ZW0gYXMgYW55KS50cmFuc2Zvcm07XG4gICAgICAgIGlmICghdHJhbnNmb3JtIHx8IHRyYW5zZm9ybS5sZW5ndGggPCA2KSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHggPSB0cmFuc2Zvcm1bNF07IC8vIHRyYW5zbGF0ZVhcbiAgICAgICAgY29uc3QgeSA9IHRyYW5zZm9ybVs1XTsgLy8gdHJhbnNsYXRlWVxuICAgICAgICBcbiAgICAgICAgLy8gUm91bmQgWSBjb29yZGluYXRlIHdpdGggdG9sZXJhbmNlIHRvIGdyb3VwIGl0ZW1zIG9uIHNhbWUgbGluZVxuICAgICAgICBjb25zdCB5S2V5ID0gTWF0aC5yb3VuZCh5IC8gTElORV9UT0xFUkFOQ0UpICogTElORV9UT0xFUkFOQ0U7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWxpbmVHcm91cHNbeUtleV0pIHtcbiAgICAgICAgICBsaW5lR3JvdXBzW3lLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGluZUdyb3Vwc1t5S2V5XS5wdXNoKHsgc3RyOiBpdGVtLnN0ciwgeCB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU29ydCBsaW5lcyBieSBZLWNvb3JkaW5hdGUgKGRlc2NlbmRpbmcsIHNpbmNlIFBERiBZIG9yaWdpbiBpcyBib3R0b20tbGVmdClcbiAgICAgIGNvbnN0IHNvcnRlZFlzID0gT2JqZWN0LmtleXMobGluZUdyb3VwcylcbiAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIEhpZ2hlciBZID0gaGlnaGVyIG9uIHBhZ2UsIHNvIHNvcnQgZGVzY2VuZGluZ1xuICAgICAgXG4gICAgICAvLyBCdWlsZCBwYWdlIHRleHQgd2l0aCBwcm9wZXIgbGluZSBicmVha3NcbiAgICAgIGNvbnN0IGxpbmVzID0gc29ydGVkWXMubWFwKHlLZXkgPT4ge1xuICAgICAgICByZXR1cm4gbGluZUdyb3Vwc1t5S2V5XVxuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnggLSBiLngpIC8vIFNvcnQgaXRlbXMgbGVmdCB0byByaWdodFxuICAgICAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLnN0cilcbiAgICAgICAgICAuam9pbignICcpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhZ2VUZXh0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICBmdWxsVGV4dCArPSBwYWdlVGV4dCArICdcXG4nO1xuICAgICAgbG9nLmRlYnVnKGBQYWdlICR7aX0gZXh0cmFjdGVkYCwgeyB0ZXh0TGVuZ3RoOiBwYWdlVGV4dC5sZW5ndGgsIGxpbmVDb3VudDogbGluZXMubGVuZ3RoIH0pO1xuICAgIH1cblxuICAgIGxvZy5pbmZvKCdQREYgdGV4dCBleHRyYWN0aW9uIGNvbXBsZXRlJywgeyB0b3RhbFRleHRMZW5ndGg6IGZ1bGxUZXh0Lmxlbmd0aCB9KTtcbiAgICByZXR1cm4gZnVsbFRleHQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBsb2cuZXJyb3IoJ1BERiBleHRyYWN0aW9uIGZhaWxlZCcsIGVycm9yKTtcbiAgICBsb2cuZXJyb3IoJ0Vycm9yIGRldGFpbHMnLCB7IFxuICAgICAgbmFtZTogZXJyb3I/Lm5hbWUsIFxuICAgICAgbWVzc2FnZTogZXJyb3I/Lm1lc3NhZ2UsXG4gICAgICBjb2RlOiBlcnJvcj8uY29kZVxuICAgIH0pO1xuICAgIFxuICAgIC8vIE1vcmUgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXMgYmFzZWQgb24gUERGLmpzIGVycm9yIHR5cGVzXG4gICAgaWYgKGVycm9yPy5uYW1lID09PSAnUGFzc3dvcmRFeGNlcHRpb24nIHx8IGVycm9yPy5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwYXNzd29yZCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZC4gUGxlYXNlIGNoZWNrIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgfSBlbHNlIGlmIChlcnJvcj8ubmFtZSA9PT0gJ0ludmFsaWRQREZFeGNlcHRpb24nIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcygnSW52YWxpZCBQREYnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBERiBmaWxlLiBQbGVhc2UgdXBsb2FkIGEgdmFsaWQgQ0FTIFBERi4nKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcygnd29ya2VyJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUERGIHByb2Nlc3NpbmcgZmFpbGVkLiBQbGVhc2UgcmVmcmVzaCBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKCdlbmNyeXB0ZWQnKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ0VuY3J5cHRlZCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZC4gUGxlYXNlIGNoZWNrIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIFxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4dHJhY3QgUERGIHRleHQ6ICR7ZXJyb3I/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlrZWx5RGF0ZShudW1TdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBudW0gPSBudW1TdHIucmVwbGFjZSgvLC9nLCAnJyk7XG4gIGlmIChudW0ubGVuZ3RoID09PSA4ICYmIC9eXFxkezh9JC8udGVzdChudW0pKSB7XG4gICAgY29uc3QgZGF5ID0gcGFyc2VJbnQobnVtLnN1YnN0cmluZygwLCAyKSk7XG4gICAgY29uc3QgbW9udGggPSBwYXJzZUludChudW0uc3Vic3RyaW5nKDIsIDQpKTtcbiAgICBpZiAoZGF5ID49IDEgJiYgZGF5IDw9IDMxICYmIG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIpIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChudW0ubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RDdXJyZW5jeVZhbHVlcyh0ZXh0OiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gIGNvbnN0IHZhbHVlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgL+KCuVxccyooW1xcZCxdKyg/OlxcLlxcZHsxLDJ9KT8pL2csXG4gICAgL1JzXFwuP1xccyooW1xcZCxdKyg/OlxcLlxcZHsxLDJ9KT8pL2dpLFxuICAgIC9JTlJcXHMqKFtcXGQsXSsoPzpcXC5cXGR7MSwyfSk/KS9naSxcbiAgXTtcbiAgXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgIGxldCBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbnVtU3RyID0gbWF0Y2hbMV0ucmVwbGFjZSgvLC9nLCAnJyk7XG4gICAgICBpZiAoIWlzTGlrZWx5RGF0ZShudW1TdHIpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdChudW1TdHIpO1xuICAgICAgICBpZiAodmFsdWUgPiAwICYmIHZhbHVlIDwgMTAwMDAwMDAwMDAwKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0FTVGV4dCh0ZXh0OiBzdHJpbmcpOiBQYXJzZWRDQVNEYXRhIHtcbiAgY29uc3QgZnVuZHM6IEV4dHJhY3RlZEZ1bmRbXSA9IFtdO1xuICBsZXQgdG90YWxWYWx1ZSA9IDA7XG4gIGxldCB0b3RhbEludmVzdGVkID0gMDtcblxuICBsb2cuZGVidWcoJ1N0YXJ0aW5nIENBUyB0ZXh0IHBhcnNpbmcnKTtcbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KC9bXFxuXFxyXSsvKTtcbiAgXG4gIGNvbnN0IGZ1bmRzQnlOYW1lOiB7IFtrZXk6IHN0cmluZ106IEV4dHJhY3RlZEZ1bmQgfSA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuICAgIGlmICghbGluZSkgY29udGludWU7XG5cbiAgICAvLyBMb29rIGZvciBmdW5kIGhlYWRlciBsaW5lczogY29udGFpbnMgZnVuZCBjb2RlICsgZnVuZCBuYW1lICsgRGlyZWN0L0dyb3d0aC9EaXZpZGVuZC9SZWd1bGFyXG4gICAgLy8gRXhhbXBsZTogXCIxMDFMQ0RHRyAtIENhbmFyYSBSb2JlY28gTGFyZ2UgQ2FwIEZ1bmQgLSBEaXJlY3QgR3Jvd3RoXCJcbiAgICAvLyBNb3JlIGZsZXhpYmxlOiBubyBsaW5lLXN0YXJ0IGFuY2hvciwgYWxsb3cgbXVsdGlwbGUgc3BhY2VzIGFuZCB2YXJpb3VzIHNlcGFyYXRvcnNcbiAgICAvLyBGdW5kIGNvZGVzIGNhbiBzdGFydCB3aXRoIG51bWJlcnMgKGUuZy4sIDEwMUxDREdHLCAxMjhTQ0RHRylcbiAgICBjb25zdCBmdW5kSGVhZGVyTWF0Y2ggPSBsaW5lLm1hdGNoKC8oW0EtWjAtOV17NSwxMH0pXFxzKlst4oCTXVxccyooW0EtWmEtejAtOVxcc1xcLSYoKScuXSs/KVxccypbLeKAk+KAlF1cXHMqKERpcmVjdHxSZWd1bGFyfEdyb3d0aHxEaXZpZGVuZHxESVJFQ1R8UkVHVUxBUnxHUk9XVEh8RElWSURFTkQpL2kpO1xuICAgIFxuICAgIGlmIChmdW5kSGVhZGVyTWF0Y2gpIHtcbiAgICAgIGNvbnN0IGZ1bmRDb2RlID0gZnVuZEhlYWRlck1hdGNoWzFdO1xuICAgICAgY29uc3QgZnVuZE5hbWUgPSBmdW5kSGVhZGVyTWF0Y2hbMl0udHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIFxuICAgICAgbG9nLmRlYnVnKCdGb3VuZCBmdW5kIGhlYWRlcjonLCB7IGZ1bmRDb2RlLCBmdW5kTmFtZSwgbGluZTogbGluZS5zdWJzdHJpbmcoMCwgMTAwKSB9KTtcblxuICAgICAgLy8gTG9vayBmb3IgSVNJTiBhbmQgb3RoZXIgZGV0YWlscyBvbiBuZXh0IGxpbmVzXG4gICAgICBsZXQgcGxhblR5cGUgPSAnUmVndWxhcic7XG4gICAgICBsZXQgZm9saW8gPSAnTi9BJztcbiAgICAgIGxldCBpc2luID0gJyc7XG4gICAgICBsZXQgYW1jID0gJ1Vua25vd24nO1xuXG4gICAgICAvLyBTZWFyY2ggYWhlYWQgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgTWF0aC5taW4oaSArIDEwLCBsaW5lcy5sZW5ndGgpOyBqKyspIHtcbiAgICAgICAgY29uc3QgZGV0YWlsTGluZSA9IGxpbmVzW2pdLnRyaW0oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvb2sgZm9yIHBsYW4gdHlwZVxuICAgICAgICBpZiAoL0RpcmVjdHxSZWd1bGFyfERJUkVDVHxSRUdVTEFSL2kudGVzdChkZXRhaWxMaW5lKSkge1xuICAgICAgICAgIGNvbnN0IHBsYW5NYXRjaCA9IGRldGFpbExpbmUubWF0Y2goLyhEaXJlY3R8UmVndWxhcnxESVJFQ1R8UkVHVUxBUikvaSk7XG4gICAgICAgICAgaWYgKHBsYW5NYXRjaCkgcGxhblR5cGUgPSBwbGFuTWF0Y2hbMV0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwbGFuTWF0Y2hbMV0uc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTG9vayBmb3IgZm9saW9cbiAgICAgICAgY29uc3QgZm9saW9NYXRjaCA9IGRldGFpbExpbmUubWF0Y2goL0ZvbGlvXFxzKyg/Ok5vKT9bOlxcc10qKFtBLVowLTlcXC9cXC1dKykvaSk7XG4gICAgICAgIGlmIChmb2xpb01hdGNoKSBmb2xpbyA9IGZvbGlvTWF0Y2hbMV0udHJpbSgpLnN1YnN0cmluZygwLCAyNSk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb29rIGZvciBJU0lOXG4gICAgICAgIGNvbnN0IGlzaW5NYXRjaCA9IGRldGFpbExpbmUubWF0Y2goL0lTSU5bOlxcc10qKFtBLVowLTlcXHNdKykvaSk7XG4gICAgICAgIGlmIChpc2luTWF0Y2gpIGlzaW4gPSBpc2luTWF0Y2hbMV0udHJpbSgpLnN1YnN0cmluZygwLCAxNSk7XG4gICAgICAgIFxuICAgICAgICAvLyBCcmVhayBpZiB3ZSBoaXQgbmV4dCBmdW5kIG9yIHRyYW5zYWN0aW9uIHNlY3Rpb25cbiAgICAgICAgaWYgKC9bQS1aMC05XXs1LDEwfVxccypbLeKAk11cXHMqW0EtWmEtel0vaS50ZXN0KGRldGFpbExpbmUpIHx8IGRldGFpbExpbmUubWF0Y2goL0RhdGUuKkFtb3VudC4qUHJpY2UvKSkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgQU1DIGZyb20gZnVuZCBuYW1lXG4gICAgICBjb25zdCBhbWNNYXRjaCA9IGZ1bmROYW1lLm1hdGNoKC8oSUNJQ0l8SERGQ3xBeGlzfFNCSXxNb3RpbGFsfEZyYW5rbGlufEtvdGFrfERTUHxMJlR8QWRpdHlhfE5pcHBvbnxKTXxJREZDfENhbmFyYXxMSUN8VVRJfFRhdGF8TWFoaW5kcmF8UXVhbnR1bXxJbnZlc2NvfFBHSU18TWlyYWV8UGFyYWcgUGFyaWtofFBQRkFTfEVkZWx3ZWlzc3xTdW5kYXJhbSkvaSk7XG4gICAgICBhbWMgPSBhbWNNYXRjaCA/IGFtY01hdGNoWzFdIDogJ1Vua25vd24nO1xuXG4gICAgICAvLyBOb3cgc2VhcmNoIGZvciBNYXJrZXQgVmFsdWUgYW5kIENvc3QgVmFsdWUgZm9yIHRoaXMgZnVuZFxuICAgICAgbGV0IG1hcmtldFZhbHVlID0gMDtcbiAgICAgIGxldCBjb3N0VmFsdWUgPSAwO1xuXG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IE1hdGgubWluKGkgKyA1MCwgbGluZXMubGVuZ3RoKTsgaisrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlTGluZSA9IGxpbmVzW2pdLnRyaW0oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvb2sgZm9yIE1hcmtldCBWYWx1ZVxuICAgICAgICBjb25zdCBtdk1hdGNoID0gdmFsdWVMaW5lLm1hdGNoKC9NYXJrZXRcXHMrVmFsdWUuKj9JTlJcXHMrKFtcXGQsXSsoPzpcXC5cXGR7MSwyfSk/KS9pKTtcbiAgICAgICAgaWYgKG12TWF0Y2gpIHtcbiAgICAgICAgICBtYXJrZXRWYWx1ZSA9IHBhcnNlRmxvYXQobXZNYXRjaFsxXS5yZXBsYWNlKC8sL2csICcnKSk7XG4gICAgICAgICAgbG9nLmRlYnVnKCdGb3VuZCBtYXJrZXQgdmFsdWU6JywgeyBmdW5kQ29kZSwgbWFya2V0VmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExvb2sgZm9yIENvc3QgVmFsdWUgb3IgVG90YWwgQ29zdCBWYWx1ZVxuICAgICAgICBjb25zdCBjdk1hdGNoID0gdmFsdWVMaW5lLm1hdGNoKC8oPzpUb3RhbFxccyspP0Nvc3RcXHMrVmFsdWUuKj9JTlI/XFxzKls6XFxzXSooW1xcZCxdKyg/OlxcLlxcZHsxLDJ9KT8pL2kpO1xuICAgICAgICBpZiAoY3ZNYXRjaCkge1xuICAgICAgICAgIGNvc3RWYWx1ZSA9IHBhcnNlRmxvYXQoY3ZNYXRjaFsxXS5yZXBsYWNlKC8sL2csICcnKSk7XG4gICAgICAgICAgbG9nLmRlYnVnKCdGb3VuZCBjb3N0IHZhbHVlOicsIHsgZnVuZENvZGUsIGNvc3RWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQnJlYWsgaWYgd2UgaGl0IG5leHQgZnVuZFxuICAgICAgICBpZiAoaiA+IGkgJiYgL15bQS1aMC05XXs1LDh9XFxzKi0vaS50ZXN0KHZhbHVlTGluZSkpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFya2V0VmFsdWUgPiAwIHx8IGNvc3RWYWx1ZSA+IDApIHtcbiAgICAgICAgaWYgKGNvc3RWYWx1ZSA9PT0gMCkgY29zdFZhbHVlID0gbWFya2V0VmFsdWU7XG4gICAgICAgIGlmIChtYXJrZXRWYWx1ZSA9PT0gMCkgbWFya2V0VmFsdWUgPSBjb3N0VmFsdWU7XG5cbiAgICAgICAgbG9nLmRlYnVnKCdBZGRpbmcgZnVuZCBmcm9tIGhlYWRlcjonLCB7IGZ1bmRDb2RlLCBmdW5kTmFtZSwgbWFya2V0VmFsdWUsIGNvc3RWYWx1ZSwgcGxhblR5cGUgfSk7XG4gICAgICAgIFxuICAgICAgICBmdW5kc0J5TmFtZVtmdW5kQ29kZV0gPSB7XG4gICAgICAgICAgbmFtZTogZnVuZE5hbWUsXG4gICAgICAgICAgZm9saW8sXG4gICAgICAgICAgdmFsdWU6IG1hcmtldFZhbHVlLFxuICAgICAgICAgIGludmVzdGVkOiBjb3N0VmFsdWUsXG4gICAgICAgICAgcGxhblR5cGUsXG4gICAgICAgICAgYW1jLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgdG8gYXJyYXkgYW5kIHN1bSB0b3RhbHNcbiAgZm9yIChjb25zdCBmdW5kQ29kZSBpbiBmdW5kc0J5TmFtZSkge1xuICAgIGNvbnN0IGZ1bmQgPSBmdW5kc0J5TmFtZVtmdW5kQ29kZV07XG4gICAgaWYgKGZ1bmQudmFsdWUgPiAwIHx8IGZ1bmQuaW52ZXN0ZWQgPiAwKSB7XG4gICAgICBmdW5kcy5wdXNoKGZ1bmQpO1xuICAgICAgdG90YWxWYWx1ZSArPSBmdW5kLnZhbHVlO1xuICAgICAgdG90YWxJbnZlc3RlZCArPSBmdW5kLmludmVzdGVkO1xuICAgIH1cbiAgfVxuXG4gIGxvZy5kZWJ1ZygnRmluYWwgcGFyc2VkIGRhdGE6JywgeyBcbiAgICBmdW5kc0NvdW50OiBmdW5kcy5sZW5ndGgsIFxuICAgIHRvdGFsVmFsdWUsIFxuICAgIHRvdGFsSW52ZXN0ZWQsXG4gICAgZnVuZHM6IGZ1bmRzLm1hcChmID0+ICh7IG5hbWU6IGYubmFtZS5zdWJzdHJpbmcoMCwgMzApLCB2YWx1ZTogZi52YWx1ZSwgaW52ZXN0ZWQ6IGYuaW52ZXN0ZWQgfSkpXG4gIH0pO1xuICBcbiAgcmV0dXJuIHtcbiAgICBmdW5kcyxcbiAgICB0b3RhbFZhbHVlLFxuICAgIHRvdGFsSW52ZXN0ZWQsXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUNBU0ZpbGUoZmlsZTogRmlsZSwgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8UGFyc2VkQ0FTRGF0YT4ge1xuICBsb2cuaW5mbygnPT09IFN0YXJ0aW5nIENBUyBmaWxlIHBhcnNpbmcgPT09Jyk7XG4gIGxvZy5pbmZvKCdGaWxlIGRldGFpbHMnLCB7IG5hbWU6IGZpbGUubmFtZSwgc2l6ZTogZmlsZS5zaXplLCB0eXBlOiBmaWxlLnR5cGUgfSk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgbG9nLmluZm8oJ1N0ZXAgMTogRXh0cmFjdGluZyB0ZXh0IGZyb20gUERGLi4uJyk7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IGV4dHJhY3RUZXh0RnJvbVBERihmaWxlLCBwYXNzd29yZCk7XG4gICAgbG9nLmluZm8oJ1N0ZXAgMSBjb21wbGV0ZTogVGV4dCBleHRyYWN0ZWQnLCB7IHRleHRMZW5ndGg6IHRleHQubGVuZ3RoIH0pO1xuICAgIFxuICAgIGxvZy5pbmZvKCdTdGVwIDI6IFBhcnNpbmcgQ0FTIHRleHQgZm9yIGZ1bmRzLi4uJyk7XG4gICAgY29uc3QgZGF0YSA9IHBhcnNlQ0FTVGV4dCh0ZXh0KTtcbiAgICBsb2cuaW5mbygnU3RlcCAyIGNvbXBsZXRlOiBUZXh0IHBhcnNlZCcsIHsgXG4gICAgICBmdW5kc0NvdW50OiBkYXRhLmZ1bmRzLmxlbmd0aCwgXG4gICAgICB0b3RhbFZhbHVlOiBkYXRhLnRvdGFsVmFsdWUsXG4gICAgICB0b3RhbEludmVzdGVkOiBkYXRhLnRvdGFsSW52ZXN0ZWQgXG4gICAgfSk7XG5cbiAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSAoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgwKTtcbiAgICBsb2cuaW5mbyhgPT09IFBhcnNpbmcgY29tcGxldGUgaW4gJHtkdXJhdGlvbn1tcyA9PT1gKTtcbiAgICBsb2cuaW5mbygnUmVzdWx0cycsIHsgXG4gICAgICBmdW5kczogZGF0YS5mdW5kcy5sZW5ndGgsIFxuICAgICAgdG90YWxWYWx1ZTogYOKCuSR7ZGF0YS50b3RhbFZhbHVlLnRvTG9jYWxlU3RyaW5nKCdlbi1JTicpfWAgXG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YS5mdW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZy53YXJuKCdObyBmdW5kcyBmb3VuZCBpbiBwYXJzZWQgZGF0YScpO1xuICAgICAgbG9nLmRlYnVnKCdGaXJzdCAxMDAwIGNoYXJzIG9mIGV4dHJhY3RlZCB0ZXh0OicsIHRleHQuc3Vic3RyaW5nKDAsIDEwMDApKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZnVuZHMgZm91bmQgaW4gQ0FTLiBQbGVhc2UgY2hlY2sgdGhlIGZpbGUgZm9ybWF0IGFuZCBwYXNzd29yZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsb2cuZXJyb3IoYD09PSBQYXJzaW5nIGZhaWxlZCBhZnRlciAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDApfW1zID09PWApO1xuICAgIGxvZy5lcnJvcignRXJyb3IgaW4gcGFyc2VDQVNGaWxlJywgZXJyb3IpO1xuICAgIGxvZy5lcnJvcignRXJyb3IgdHlwZScsIHsgXG4gICAgICBuYW1lOiBlcnJvcj8ubmFtZSwgXG4gICAgICBtZXNzYWdlOiBlcnJvcj8ubWVzc2FnZSxcbiAgICAgIGlzRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgXG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmUtdGhyb3cgd2l0aCBwcm9wZXIgZXJyb3IgbWVzc2FnZVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgQ0FTIFBERi4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInBkZmpzTGliIiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsIndvcmtlclNyYyIsImxvZyIsImluZm8iLCJtc2ciLCJkYXRhIiwiY29uc29sZSIsInVuZGVmaW5lZCIsImVycm9yIiwic3RhY2siLCJkZWJ1ZyIsIndhcm4iLCJleHRyYWN0VGV4dEZyb21QREYiLCJmaWxlIiwicGFzc3dvcmQiLCJmaWxlTmFtZSIsIm5hbWUiLCJmaWxlU2l6ZSIsInNpemUiLCJmaWxlVHlwZSIsInR5cGUiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJwYXNzd29yZFN0ciIsImhhc1Bhc3N3b3JkIiwibGVuZ3RoIiwibG9hZGluZ1Rhc2siLCJnZXREb2N1bWVudCIsInBhc3N3b3JkQXR0ZW1wdGVkIiwib25QYXNzd29yZCIsInVwZGF0ZVBhc3N3b3JkIiwicmVhc29uIiwiZXJyIiwicGRmIiwicHJvbWlzZSIsIm51bVBhZ2VzIiwiZnVsbFRleHQiLCJpIiwicGFnZSIsImdldFBhZ2UiLCJ0ZXh0Q29udGVudCIsImdldFRleHRDb250ZW50IiwiTElORV9UT0xFUkFOQ0UiLCJsaW5lR3JvdXBzIiwiaXRlbSIsIml0ZW1zIiwic3RyIiwidHJpbSIsInRyYW5zZm9ybSIsIngiLCJ5IiwieUtleSIsIk1hdGgiLCJyb3VuZCIsInB1c2giLCJzb3J0ZWRZcyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJOdW1iZXIiLCJzb3J0IiwiYSIsImIiLCJsaW5lcyIsImpvaW4iLCJwYWdlVGV4dCIsInRleHRMZW5ndGgiLCJsaW5lQ291bnQiLCJ0b3RhbFRleHRMZW5ndGgiLCJtZXNzYWdlIiwiY29kZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJFcnJvciIsImlzTGlrZWx5RGF0ZSIsIm51bVN0ciIsIm51bSIsInJlcGxhY2UiLCJ0ZXN0IiwiZGF5IiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJtb250aCIsImV4dHJhY3RDdXJyZW5jeVZhbHVlcyIsInRleHQiLCJ2YWx1ZXMiLCJwYXR0ZXJucyIsInBhdHRlcm4iLCJtYXRjaCIsImV4ZWMiLCJ2YWx1ZSIsInBhcnNlRmxvYXQiLCJwYXJzZUNBU1RleHQiLCJmdW5kcyIsInRvdGFsVmFsdWUiLCJ0b3RhbEludmVzdGVkIiwic3BsaXQiLCJmdW5kc0J5TmFtZSIsImxpbmUiLCJmdW5kSGVhZGVyTWF0Y2giLCJmdW5kQ29kZSIsImZ1bmROYW1lIiwicGxhblR5cGUiLCJmb2xpbyIsImlzaW4iLCJhbWMiLCJqIiwibWluIiwiZGV0YWlsTGluZSIsInBsYW5NYXRjaCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJmb2xpb01hdGNoIiwiaXNpbk1hdGNoIiwiYW1jTWF0Y2giLCJtYXJrZXRWYWx1ZSIsImNvc3RWYWx1ZSIsInZhbHVlTGluZSIsIm12TWF0Y2giLCJjdk1hdGNoIiwiaW52ZXN0ZWQiLCJmdW5kIiwiZnVuZHNDb3VudCIsImYiLCJwYXJzZUNBU0ZpbGUiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVuZFRpbWUiLCJkdXJhdGlvbiIsInRvRml4ZWQiLCJ0b0xvY2FsZVN0cmluZyIsImlzRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/pdfParser.ts\n");

/***/ })

};
;