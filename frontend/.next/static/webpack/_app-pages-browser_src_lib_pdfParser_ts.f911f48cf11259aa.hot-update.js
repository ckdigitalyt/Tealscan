"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_pdfParser_ts",{

/***/ "(app-pages-browser)/./src/lib/pdfParser.ts":
/*!******************************!*\
  !*** ./src/lib/pdfParser.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseCASFile: function() { return /* binding */ parseCASFile; }\n/* harmony export */ });\n/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist */ \"(app-pages-browser)/../node_modules/pdfjs-dist/build/pdf.mjs\");\n\n// Set worker source - use the version from package.json\n// Get the actual version of pdfjs-dist being used\nconst pdfWorkerVersion = \"4.4.168\";\npdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc = \"https://unpkg.com/pdfjs-dist@\".concat(pdfWorkerVersion, \"/build/pdf.worker.min.mjs\");\n// Detailed logging helper\nconst log = {\n    info: (msg, data)=>{\n        console.log(\"[PDF-PARSER] INFO: \".concat(msg), data !== undefined ? data : \"\");\n    },\n    error: (msg, error)=>{\n        console.error(\"[PDF-PARSER] ERROR: \".concat(msg), error !== undefined ? error : \"\");\n        if (error === null || error === void 0 ? void 0 : error.stack) console.error(\"[PDF-PARSER] Stack:\", error.stack);\n    },\n    debug: (msg, data)=>{\n        console.log(\"[PDF-PARSER] DEBUG: \".concat(msg), data !== undefined ? data : \"\");\n    },\n    warn: (msg, data)=>{\n        console.warn(\"[PDF-PARSER] WARN: \".concat(msg), data !== undefined ? data : \"\");\n    }\n};\nasync function extractTextFromPDF(file, password) {\n    log.info(\"Starting PDF text extraction\", {\n        fileName: file.name,\n        fileSize: file.size,\n        fileType: file.type\n    });\n    try {\n        log.debug(\"Converting file to ArrayBuffer...\");\n        const arrayBuffer = await file.arrayBuffer();\n        log.debug(\"ArrayBuffer created\", {\n            byteLength: arrayBuffer.byteLength\n        });\n        log.debug(\"PDF.js worker source:\", pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc);\n        log.info(\"Loading PDF document with password...\");\n        // PDF.js can accept password as string or Uint8Array\n        // Try with string first, then handle password callback for encrypted PDFs\n        const passwordStr = password || \"\";\n        log.debug(\"Preparing password for PDF.js\", {\n            hasPassword: passwordStr.length > 0\n        });\n        const loadingTask = pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            password: passwordStr\n        });\n        // Handle password-protected PDF - set callback to provide password if needed\n        let passwordAttempted = false;\n        loadingTask.onPassword = (updatePassword, reason)=>{\n            log.debug(\"PDF password callback triggered\", {\n                reason,\n                passwordAttempted\n            });\n            // Reason: 1 = user password, 2 = owner password\n            if (!passwordAttempted && passwordStr) {\n                passwordAttempted = true;\n                try {\n                    // Try updating with the provided password\n                    updatePassword(passwordStr);\n                } catch (err) {\n                    log.error(\"Error calling updatePassword\", err);\n                }\n            }\n        };\n        log.debug(\"PDF loading task created, awaiting promise...\");\n        const pdf = await loadingTask.promise;\n        log.info(\"PDF loaded successfully\", {\n            numPages: pdf.numPages\n        });\n        let fullText = \"\";\n        for(let i = 1; i <= pdf.numPages; i++){\n            log.debug(\"Extracting text from page \".concat(i, \"/\").concat(pdf.numPages, \"...\"));\n            const page = await pdf.getPage(i);\n            const textContent = await page.getTextContent();\n            const pageText = textContent.items.map((item)=>item.str).join(\" \");\n            fullText += pageText + \"\\n\";\n            log.debug(\"Page \".concat(i, \" extracted\"), {\n                textLength: pageText.length\n            });\n        }\n        log.info(\"PDF text extraction complete\", {\n            totalTextLength: fullText.length\n        });\n        return fullText;\n    } catch (error) {\n        var _error_message, _error_message1, _error_message2, _error_message3, _error_message4;\n        log.error(\"PDF extraction failed\", error);\n        log.error(\"Error details\", {\n            name: error === null || error === void 0 ? void 0 : error.name,\n            message: error === null || error === void 0 ? void 0 : error.message,\n            code: error === null || error === void 0 ? void 0 : error.code\n        });\n        // More specific error messages based on PDF.js error types\n        if ((error === null || error === void 0 ? void 0 : error.name) === \"PasswordException\" || (error === null || error === void 0 ? void 0 : (_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.toLowerCase().includes(\"password\"))) {\n            throw new Error(\"Incorrect password. Please check and try again.\");\n        } else if ((error === null || error === void 0 ? void 0 : error.name) === \"InvalidPDFException\" || (error === null || error === void 0 ? void 0 : (_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"Invalid PDF\"))) {\n            throw new Error(\"Invalid PDF file. Please upload a valid CAS PDF.\");\n        } else if (error === null || error === void 0 ? void 0 : (_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"worker\")) {\n            throw new Error(\"PDF processing failed. Please refresh and try again.\");\n        } else if ((error === null || error === void 0 ? void 0 : (_error_message3 = error.message) === null || _error_message3 === void 0 ? void 0 : _error_message3.includes(\"encrypted\")) || (error === null || error === void 0 ? void 0 : (_error_message4 = error.message) === null || _error_message4 === void 0 ? void 0 : _error_message4.includes(\"Encrypted\"))) {\n            throw new Error(\"Incorrect password. Please check and try again.\");\n        }\n        throw new Error(\"Failed to extract PDF text: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\"));\n    }\n}\nfunction parseCASText(text) {\n    const funds = [];\n    let totalValue = 0;\n    let totalInvested = 0;\n    // Regex patterns for CAS format\n    const fundPattern = /([A-Za-z\\s\\-&()]+?)\\s+(?:ISIN:|Growth|Dividend)\\s+([A-Z0-9]{12})?[\\s\\S]*?(?:Plan:|Direct|Regular)\\s+(Direct|Regular)[\\s\\S]*?₹\\s+([\\d,]+\\.?\\d*)\\s+₹\\s+([\\d,]+\\.?\\d*)/gi;\n    const folio_pattern = /Folio\\s+([A-Z0-9\\s/\\-]+?)\\s+(?=Folio|Account|Statement|$)/i;\n    const amc_pattern = /(ICICI|HDFC|Axis|SBI|Motilal|Franklin|Kotak|DSP|L&T|Aditya Birla|Nippon|JM Financial|IDFC|Canara|HDFC Life|LIC)/i;\n    const lines = text.split(\"\\n\");\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        // Try to match fund entry\n        if (line.match(/ISIN:|Growth|Dividend/) && line.match(/Direct|Regular/)) {\n            try {\n                // Extract fund name\n                const nameMatch = line.match(/^([A-Za-z\\s\\-&()]+?)\\s+(?:ISIN:|Growth|Dividend)/);\n                const name = nameMatch ? nameMatch[1].trim() : \"Unknown Fund\";\n                // Extract plan type\n                const planMatch = line.match(/(Direct|Regular)/);\n                const planType = planMatch ? planMatch[1] : \"Regular\";\n                // Extract current value and invested amount\n                const valueMatch = line.match(/₹\\s+([\\d,]+\\.?\\d*)/g);\n                if (valueMatch && valueMatch.length >= 2) {\n                    const currentValue = parseFloat(valueMatch[valueMatch.length - 1].replace(/₹\\s+/, \"\").replace(/,/g, \"\"));\n                    const investedAmount = parseFloat(valueMatch[0].replace(/₹\\s+/, \"\").replace(/,/g, \"\"));\n                    // Extract folio\n                    const folioMatch = lines.slice(Math.max(0, i - 5), i).reverse().find((l)=>l.match(/[A-Z0-9\\/\\-]{10,}/));\n                    const folio = folioMatch ? folioMatch.trim().substring(0, 20) : \"N/A\";\n                    // Guess AMC from fund name\n                    const amcMatch = name.match(/(ICICI|HDFC|Axis|SBI|Motilal|Franklin|Kotak|DSP|L&T|Aditya|Nippon|JM|IDFC|Canara|LIC)/i);\n                    const amc = amcMatch ? amcMatch[1] : \"Unknown\";\n                    if (currentValue > 0) {\n                        funds.push({\n                            name,\n                            folio,\n                            value: currentValue,\n                            invested: investedAmount,\n                            planType,\n                            amc\n                        });\n                        totalValue += currentValue;\n                        totalInvested += investedAmount;\n                    }\n                }\n            } catch (e) {\n            // Continue parsing\n            }\n        }\n    }\n    return {\n        funds,\n        totalValue,\n        totalInvested\n    };\n}\nasync function parseCASFile(file, password) {\n    log.info(\"=== Starting CAS file parsing ===\");\n    log.info(\"File details\", {\n        name: file.name,\n        size: file.size,\n        type: file.type\n    });\n    const startTime = performance.now();\n    try {\n        log.info(\"Step 1: Extracting text from PDF...\");\n        const text = await extractTextFromPDF(file, password);\n        log.info(\"Step 1 complete: Text extracted\", {\n            textLength: text.length\n        });\n        log.info(\"Step 2: Parsing CAS text for funds...\");\n        const data = parseCASText(text);\n        log.info(\"Step 2 complete: Text parsed\", {\n            fundsCount: data.funds.length,\n            totalValue: data.totalValue,\n            totalInvested: data.totalInvested\n        });\n        const endTime = performance.now();\n        const duration = (endTime - startTime).toFixed(0);\n        log.info(\"=== Parsing complete in \".concat(duration, \"ms ===\"));\n        log.info(\"Results\", {\n            funds: data.funds.length,\n            totalValue: \"₹\".concat(data.totalValue.toLocaleString(\"en-IN\"))\n        });\n        if (data.funds.length === 0) {\n            log.warn(\"No funds found in parsed data\");\n            log.debug(\"First 1000 chars of extracted text:\", text.substring(0, 1000));\n            throw new Error(\"No funds found in CAS. Please check the file format and password.\");\n        }\n        return data;\n    } catch (error) {\n        const endTime = performance.now();\n        log.error(\"=== Parsing failed after \".concat((endTime - startTime).toFixed(0), \"ms ===\"));\n        log.error(\"Error in parseCASFile\", error);\n        log.error(\"Error type\", {\n            name: error === null || error === void 0 ? void 0 : error.name,\n            message: error === null || error === void 0 ? void 0 : error.message,\n            isError: error instanceof Error\n        });\n        // Re-throw with proper error message\n        if (error instanceof Error) {\n            throw error;\n        }\n        throw new Error(\"Failed to parse CAS PDF. Please try again.\");\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsNEJBQTZELE9BQWpDLENBQUN3RixVQUFVSixTQUFRLEVBQUdNLE9BQU8sQ0FBQyxJQUFHO1FBQ3ZFaEcsSUFBSU0sS0FBSyxDQUFDLHlCQUF5QkE7UUFDbkNOLElBQUlNLEtBQUssQ0FBQyxjQUFjO1lBQ3RCUSxJQUFJLEVBQUVSLGtCQUFBQSw0QkFBQUEsTUFBT1EsSUFBSTtZQUNqQmtDLE9BQU8sRUFBRTFDLGtCQUFBQSw0QkFBQUEsTUFBTzBDLE9BQU87WUFDdkJrRCxTQUFTNUYsaUJBQWlCOEM7UUFDNUI7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSTlDLGlCQUFpQjhDLE9BQU87WUFDMUIsTUFBTTlDO1FBQ1I7UUFDQSxNQUFNLElBQUk4QyxNQUFNO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9wZGZQYXJzZXIudHM/YjU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwZGZqc0xpYiBmcm9tICdwZGZqcy1kaXN0JztcblxuLy8gU2V0IHdvcmtlciBzb3VyY2UgLSB1c2UgdGhlIHZlcnNpb24gZnJvbSBwYWNrYWdlLmpzb25cbi8vIEdldCB0aGUgYWN0dWFsIHZlcnNpb24gb2YgcGRmanMtZGlzdCBiZWluZyB1c2VkXG5jb25zdCBwZGZXb3JrZXJWZXJzaW9uID0gJzQuNC4xNjgnO1xucGRmanNMaWIuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSBgaHR0cHM6Ly91bnBrZy5jb20vcGRmanMtZGlzdEAke3BkZldvcmtlclZlcnNpb259L2J1aWxkL3BkZi53b3JrZXIubWluLm1qc2A7XG5cbi8vIERldGFpbGVkIGxvZ2dpbmcgaGVscGVyXG5jb25zdCBsb2cgPSB7XG4gIGluZm86IChtc2c6IHN0cmluZywgZGF0YT86IGFueSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbUERGLVBBUlNFUl0gSU5GTzogJHttc2d9YCwgZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YSA6ICcnKTtcbiAgfSxcbiAgZXJyb3I6IChtc2c6IHN0cmluZywgZXJyb3I/OiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGBbUERGLVBBUlNFUl0gRVJST1I6ICR7bXNnfWAsIGVycm9yICE9PSB1bmRlZmluZWQgPyBlcnJvciA6ICcnKTtcbiAgICBpZiAoZXJyb3I/LnN0YWNrKSBjb25zb2xlLmVycm9yKGBbUERGLVBBUlNFUl0gU3RhY2s6YCwgZXJyb3Iuc3RhY2spO1xuICB9LFxuICBkZWJ1ZzogKG1zZzogc3RyaW5nLCBkYXRhPzogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coYFtQREYtUEFSU0VSXSBERUJVRzogJHttc2d9YCwgZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YSA6ICcnKTtcbiAgfSxcbiAgd2FybjogKG1zZzogc3RyaW5nLCBkYXRhPzogYW55KSA9PiB7XG4gICAgY29uc29sZS53YXJuKGBbUERGLVBBUlNFUl0gV0FSTjogJHttc2d9YCwgZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YSA6ICcnKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBFeHRyYWN0ZWRGdW5kIHtcbiAgbmFtZTogc3RyaW5nO1xuICBmb2xpbzogc3RyaW5nO1xuICB2YWx1ZTogbnVtYmVyO1xuICBpbnZlc3RlZDogbnVtYmVyO1xuICBwbGFuVHlwZTogc3RyaW5nO1xuICBhbWM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRDQVNEYXRhIHtcbiAgZnVuZHM6IEV4dHJhY3RlZEZ1bmRbXTtcbiAgdG90YWxWYWx1ZTogbnVtYmVyO1xuICB0b3RhbEludmVzdGVkOiBudW1iZXI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RUZXh0RnJvbVBERihmaWxlOiBGaWxlLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgbG9nLmluZm8oJ1N0YXJ0aW5nIFBERiB0ZXh0IGV4dHJhY3Rpb24nLCB7IGZpbGVOYW1lOiBmaWxlLm5hbWUsIGZpbGVTaXplOiBmaWxlLnNpemUsIGZpbGVUeXBlOiBmaWxlLnR5cGUgfSk7XG4gIFxuICB0cnkge1xuICAgIGxvZy5kZWJ1ZygnQ29udmVydGluZyBmaWxlIHRvIEFycmF5QnVmZmVyLi4uJyk7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XG4gICAgbG9nLmRlYnVnKCdBcnJheUJ1ZmZlciBjcmVhdGVkJywgeyBieXRlTGVuZ3RoOiBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIH0pO1xuICAgIFxuICAgIGxvZy5kZWJ1ZygnUERGLmpzIHdvcmtlciBzb3VyY2U6JywgcGRmanNMaWIuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMpO1xuICAgIGxvZy5pbmZvKCdMb2FkaW5nIFBERiBkb2N1bWVudCB3aXRoIHBhc3N3b3JkLi4uJyk7XG4gICAgXG4gICAgLy8gUERGLmpzIGNhbiBhY2NlcHQgcGFzc3dvcmQgYXMgc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAgICAvLyBUcnkgd2l0aCBzdHJpbmcgZmlyc3QsIHRoZW4gaGFuZGxlIHBhc3N3b3JkIGNhbGxiYWNrIGZvciBlbmNyeXB0ZWQgUERGc1xuICAgIGNvbnN0IHBhc3N3b3JkU3RyID0gcGFzc3dvcmQgfHwgJyc7XG4gICAgbG9nLmRlYnVnKCdQcmVwYXJpbmcgcGFzc3dvcmQgZm9yIFBERi5qcycsIHsgaGFzUGFzc3dvcmQ6IHBhc3N3b3JkU3RyLmxlbmd0aCA+IDAgfSk7XG4gICAgXG4gICAgY29uc3QgbG9hZGluZ1Rhc2sgPSBwZGZqc0xpYi5nZXREb2N1bWVudCh7XG4gICAgICBkYXRhOiBhcnJheUJ1ZmZlcixcbiAgICAgIHBhc3N3b3JkOiBwYXNzd29yZFN0cixcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgcGFzc3dvcmQtcHJvdGVjdGVkIFBERiAtIHNldCBjYWxsYmFjayB0byBwcm92aWRlIHBhc3N3b3JkIGlmIG5lZWRlZFxuICAgIGxldCBwYXNzd29yZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQgPSAodXBkYXRlUGFzc3dvcmQ6IEZ1bmN0aW9uLCByZWFzb246IG51bWJlcikgPT4ge1xuICAgICAgbG9nLmRlYnVnKCdQREYgcGFzc3dvcmQgY2FsbGJhY2sgdHJpZ2dlcmVkJywgeyByZWFzb24sIHBhc3N3b3JkQXR0ZW1wdGVkIH0pO1xuICAgICAgLy8gUmVhc29uOiAxID0gdXNlciBwYXNzd29yZCwgMiA9IG93bmVyIHBhc3N3b3JkXG4gICAgICBpZiAoIXBhc3N3b3JkQXR0ZW1wdGVkICYmIHBhc3N3b3JkU3RyKSB7XG4gICAgICAgIHBhc3N3b3JkQXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdXBkYXRpbmcgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3dvcmRcbiAgICAgICAgICB1cGRhdGVQYXNzd29yZChwYXNzd29yZFN0cik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcignRXJyb3IgY2FsbGluZyB1cGRhdGVQYXNzd29yZCcsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGxvZy5kZWJ1ZygnUERGIGxvYWRpbmcgdGFzayBjcmVhdGVkLCBhd2FpdGluZyBwcm9taXNlLi4uJyk7XG4gICAgY29uc3QgcGRmID0gYXdhaXQgbG9hZGluZ1Rhc2sucHJvbWlzZTtcbiAgICBsb2cuaW5mbygnUERGIGxvYWRlZCBzdWNjZXNzZnVsbHknLCB7IG51bVBhZ2VzOiBwZGYubnVtUGFnZXMgfSk7XG5cbiAgICBsZXQgZnVsbFRleHQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHBkZi5udW1QYWdlczsgaSsrKSB7XG4gICAgICBsb2cuZGVidWcoYEV4dHJhY3RpbmcgdGV4dCBmcm9tIHBhZ2UgJHtpfS8ke3BkZi5udW1QYWdlc30uLi5gKTtcbiAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBwZGYuZ2V0UGFnZShpKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gYXdhaXQgcGFnZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgcGFnZVRleHQgPSB0ZXh0Q29udGVudC5pdGVtc1xuICAgICAgICAubWFwKChpdGVtOiBhbnkpID0+IGl0ZW0uc3RyKVxuICAgICAgICAuam9pbignICcpO1xuICAgICAgZnVsbFRleHQgKz0gcGFnZVRleHQgKyAnXFxuJztcbiAgICAgIGxvZy5kZWJ1ZyhgUGFnZSAke2l9IGV4dHJhY3RlZGAsIHsgdGV4dExlbmd0aDogcGFnZVRleHQubGVuZ3RoIH0pO1xuICAgIH1cblxuICAgIGxvZy5pbmZvKCdQREYgdGV4dCBleHRyYWN0aW9uIGNvbXBsZXRlJywgeyB0b3RhbFRleHRMZW5ndGg6IGZ1bGxUZXh0Lmxlbmd0aCB9KTtcbiAgICByZXR1cm4gZnVsbFRleHQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBsb2cuZXJyb3IoJ1BERiBleHRyYWN0aW9uIGZhaWxlZCcsIGVycm9yKTtcbiAgICBsb2cuZXJyb3IoJ0Vycm9yIGRldGFpbHMnLCB7IFxuICAgICAgbmFtZTogZXJyb3I/Lm5hbWUsIFxuICAgICAgbWVzc2FnZTogZXJyb3I/Lm1lc3NhZ2UsXG4gICAgICBjb2RlOiBlcnJvcj8uY29kZVxuICAgIH0pO1xuICAgIFxuICAgIC8vIE1vcmUgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXMgYmFzZWQgb24gUERGLmpzIGVycm9yIHR5cGVzXG4gICAgaWYgKGVycm9yPy5uYW1lID09PSAnUGFzc3dvcmRFeGNlcHRpb24nIHx8IGVycm9yPy5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwYXNzd29yZCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZC4gUGxlYXNlIGNoZWNrIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgfSBlbHNlIGlmIChlcnJvcj8ubmFtZSA9PT0gJ0ludmFsaWRQREZFeGNlcHRpb24nIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcygnSW52YWxpZCBQREYnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBERiBmaWxlLiBQbGVhc2UgdXBsb2FkIGEgdmFsaWQgQ0FTIFBERi4nKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcygnd29ya2VyJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUERGIHByb2Nlc3NpbmcgZmFpbGVkLiBQbGVhc2UgcmVmcmVzaCBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKCdlbmNyeXB0ZWQnKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ0VuY3J5cHRlZCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZC4gUGxlYXNlIGNoZWNrIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIFxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4dHJhY3QgUERGIHRleHQ6ICR7ZXJyb3I/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0FTVGV4dCh0ZXh0OiBzdHJpbmcpOiBQYXJzZWRDQVNEYXRhIHtcbiAgY29uc3QgZnVuZHM6IEV4dHJhY3RlZEZ1bmRbXSA9IFtdO1xuICBsZXQgdG90YWxWYWx1ZSA9IDA7XG4gIGxldCB0b3RhbEludmVzdGVkID0gMDtcblxuICAvLyBSZWdleCBwYXR0ZXJucyBmb3IgQ0FTIGZvcm1hdFxuICBjb25zdCBmdW5kUGF0dGVybiA9IC8oW0EtWmEtelxcc1xcLSYoKV0rPylcXHMrKD86SVNJTjp8R3Jvd3RofERpdmlkZW5kKVxccysoW0EtWjAtOV17MTJ9KT9bXFxzXFxTXSo/KD86UGxhbjp8RGlyZWN0fFJlZ3VsYXIpXFxzKyhEaXJlY3R8UmVndWxhcilbXFxzXFxTXSo/4oK5XFxzKyhbXFxkLF0rXFwuP1xcZCopXFxzK+KCuVxccysoW1xcZCxdK1xcLj9cXGQqKS9naTtcbiAgXG4gIGNvbnN0IGZvbGlvX3BhdHRlcm4gPSAvRm9saW9cXHMrKFtBLVowLTlcXHMvXFwtXSs/KVxccysoPz1Gb2xpb3xBY2NvdW50fFN0YXRlbWVudHwkKS9pO1xuICBjb25zdCBhbWNfcGF0dGVybiA9IC8oSUNJQ0l8SERGQ3xBeGlzfFNCSXxNb3RpbGFsfEZyYW5rbGlufEtvdGFrfERTUHxMJlR8QWRpdHlhIEJpcmxhfE5pcHBvbnxKTSBGaW5hbmNpYWx8SURGQ3xDYW5hcmF8SERGQyBMaWZlfExJQykvaTtcblxuICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG5cbiAgICAvLyBUcnkgdG8gbWF0Y2ggZnVuZCBlbnRyeVxuICAgIGlmIChsaW5lLm1hdGNoKC9JU0lOOnxHcm93dGh8RGl2aWRlbmQvKSAmJiBsaW5lLm1hdGNoKC9EaXJlY3R8UmVndWxhci8pKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBFeHRyYWN0IGZ1bmQgbmFtZVxuICAgICAgICBjb25zdCBuYW1lTWF0Y2ggPSBsaW5lLm1hdGNoKC9eKFtBLVphLXpcXHNcXC0mKCldKz8pXFxzKyg/OklTSU46fEdyb3d0aHxEaXZpZGVuZCkvKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVNYXRjaCA/IG5hbWVNYXRjaFsxXS50cmltKCkgOiAnVW5rbm93biBGdW5kJztcblxuICAgICAgICAvLyBFeHRyYWN0IHBsYW4gdHlwZVxuICAgICAgICBjb25zdCBwbGFuTWF0Y2ggPSBsaW5lLm1hdGNoKC8oRGlyZWN0fFJlZ3VsYXIpLyk7XG4gICAgICAgIGNvbnN0IHBsYW5UeXBlID0gcGxhbk1hdGNoID8gcGxhbk1hdGNoWzFdIDogJ1JlZ3VsYXInO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgY3VycmVudCB2YWx1ZSBhbmQgaW52ZXN0ZWQgYW1vdW50XG4gICAgICAgIGNvbnN0IHZhbHVlTWF0Y2ggPSBsaW5lLm1hdGNoKC/igrlcXHMrKFtcXGQsXStcXC4/XFxkKikvZyk7XG4gICAgICAgIGlmICh2YWx1ZU1hdGNoICYmIHZhbHVlTWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlTWF0Y2hbdmFsdWVNYXRjaC5sZW5ndGggLSAxXS5yZXBsYWNlKC/igrlcXHMrLywgJycpLnJlcGxhY2UoLywvZywgJycpKTtcbiAgICAgICAgICBjb25zdCBpbnZlc3RlZEFtb3VudCA9IHBhcnNlRmxvYXQodmFsdWVNYXRjaFswXS5yZXBsYWNlKC/igrlcXHMrLywgJycpLnJlcGxhY2UoLywvZywgJycpKTtcblxuICAgICAgICAgIC8vIEV4dHJhY3QgZm9saW9cbiAgICAgICAgICBjb25zdCBmb2xpb01hdGNoID0gbGluZXMuc2xpY2UoTWF0aC5tYXgoMCwgaSAtIDUpLCBpKS5yZXZlcnNlKCkuZmluZChsID0+IGwubWF0Y2goL1tBLVowLTlcXC9cXC1dezEwLH0vKSk7XG4gICAgICAgICAgY29uc3QgZm9saW8gPSBmb2xpb01hdGNoID8gZm9saW9NYXRjaC50cmltKCkuc3Vic3RyaW5nKDAsIDIwKSA6ICdOL0EnO1xuXG4gICAgICAgICAgLy8gR3Vlc3MgQU1DIGZyb20gZnVuZCBuYW1lXG4gICAgICAgICAgY29uc3QgYW1jTWF0Y2ggPSBuYW1lLm1hdGNoKC8oSUNJQ0l8SERGQ3xBeGlzfFNCSXxNb3RpbGFsfEZyYW5rbGlufEtvdGFrfERTUHxMJlR8QWRpdHlhfE5pcHBvbnxKTXxJREZDfENhbmFyYXxMSUMpL2kpO1xuICAgICAgICAgIGNvbnN0IGFtYyA9IGFtY01hdGNoID8gYW1jTWF0Y2hbMV0gOiAnVW5rbm93bic7XG5cbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID4gMCkge1xuICAgICAgICAgICAgZnVuZHMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGZvbGlvLFxuICAgICAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgICBpbnZlc3RlZDogaW52ZXN0ZWRBbW91bnQsXG4gICAgICAgICAgICAgIHBsYW5UeXBlLFxuICAgICAgICAgICAgICBhbWMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdG90YWxWYWx1ZSArPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0b3RhbEludmVzdGVkICs9IGludmVzdGVkQW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDb250aW51ZSBwYXJzaW5nXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmdW5kcyxcbiAgICB0b3RhbFZhbHVlLFxuICAgIHRvdGFsSW52ZXN0ZWQsXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUNBU0ZpbGUoZmlsZTogRmlsZSwgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8UGFyc2VkQ0FTRGF0YT4ge1xuICBsb2cuaW5mbygnPT09IFN0YXJ0aW5nIENBUyBmaWxlIHBhcnNpbmcgPT09Jyk7XG4gIGxvZy5pbmZvKCdGaWxlIGRldGFpbHMnLCB7IG5hbWU6IGZpbGUubmFtZSwgc2l6ZTogZmlsZS5zaXplLCB0eXBlOiBmaWxlLnR5cGUgfSk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgbG9nLmluZm8oJ1N0ZXAgMTogRXh0cmFjdGluZyB0ZXh0IGZyb20gUERGLi4uJyk7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IGV4dHJhY3RUZXh0RnJvbVBERihmaWxlLCBwYXNzd29yZCk7XG4gICAgbG9nLmluZm8oJ1N0ZXAgMSBjb21wbGV0ZTogVGV4dCBleHRyYWN0ZWQnLCB7IHRleHRMZW5ndGg6IHRleHQubGVuZ3RoIH0pO1xuICAgIFxuICAgIGxvZy5pbmZvKCdTdGVwIDI6IFBhcnNpbmcgQ0FTIHRleHQgZm9yIGZ1bmRzLi4uJyk7XG4gICAgY29uc3QgZGF0YSA9IHBhcnNlQ0FTVGV4dCh0ZXh0KTtcbiAgICBsb2cuaW5mbygnU3RlcCAyIGNvbXBsZXRlOiBUZXh0IHBhcnNlZCcsIHsgXG4gICAgICBmdW5kc0NvdW50OiBkYXRhLmZ1bmRzLmxlbmd0aCwgXG4gICAgICB0b3RhbFZhbHVlOiBkYXRhLnRvdGFsVmFsdWUsXG4gICAgICB0b3RhbEludmVzdGVkOiBkYXRhLnRvdGFsSW52ZXN0ZWQgXG4gICAgfSk7XG5cbiAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSAoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgwKTtcbiAgICBsb2cuaW5mbyhgPT09IFBhcnNpbmcgY29tcGxldGUgaW4gJHtkdXJhdGlvbn1tcyA9PT1gKTtcbiAgICBsb2cuaW5mbygnUmVzdWx0cycsIHsgXG4gICAgICBmdW5kczogZGF0YS5mdW5kcy5sZW5ndGgsIFxuICAgICAgdG90YWxWYWx1ZTogYOKCuSR7ZGF0YS50b3RhbFZhbHVlLnRvTG9jYWxlU3RyaW5nKCdlbi1JTicpfWAgXG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YS5mdW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZy53YXJuKCdObyBmdW5kcyBmb3VuZCBpbiBwYXJzZWQgZGF0YScpO1xuICAgICAgbG9nLmRlYnVnKCdGaXJzdCAxMDAwIGNoYXJzIG9mIGV4dHJhY3RlZCB0ZXh0OicsIHRleHQuc3Vic3RyaW5nKDAsIDEwMDApKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZnVuZHMgZm91bmQgaW4gQ0FTLiBQbGVhc2UgY2hlY2sgdGhlIGZpbGUgZm9ybWF0IGFuZCBwYXNzd29yZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsb2cuZXJyb3IoYD09PSBQYXJzaW5nIGZhaWxlZCBhZnRlciAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDApfW1zID09PWApO1xuICAgIGxvZy5lcnJvcignRXJyb3IgaW4gcGFyc2VDQVNGaWxlJywgZXJyb3IpO1xuICAgIGxvZy5lcnJvcignRXJyb3IgdHlwZScsIHsgXG4gICAgICBuYW1lOiBlcnJvcj8ubmFtZSwgXG4gICAgICBtZXNzYWdlOiBlcnJvcj8ubWVzc2FnZSxcbiAgICAgIGlzRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgXG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmUtdGhyb3cgd2l0aCBwcm9wZXIgZXJyb3IgbWVzc2FnZVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgQ0FTIFBERi4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInBkZmpzTGliIiwicGRmV29ya2VyVmVyc2lvbiIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJ3b3JrZXJTcmMiLCJsb2ciLCJpbmZvIiwibXNnIiwiZGF0YSIsImNvbnNvbGUiLCJ1bmRlZmluZWQiLCJlcnJvciIsInN0YWNrIiwiZGVidWciLCJ3YXJuIiwiZXh0cmFjdFRleHRGcm9tUERGIiwiZmlsZSIsInBhc3N3b3JkIiwiZmlsZU5hbWUiLCJuYW1lIiwiZmlsZVNpemUiLCJzaXplIiwiZmlsZVR5cGUiLCJ0eXBlIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwicGFzc3dvcmRTdHIiLCJoYXNQYXNzd29yZCIsImxlbmd0aCIsImxvYWRpbmdUYXNrIiwiZ2V0RG9jdW1lbnQiLCJwYXNzd29yZEF0dGVtcHRlZCIsIm9uUGFzc3dvcmQiLCJ1cGRhdGVQYXNzd29yZCIsInJlYXNvbiIsImVyciIsInBkZiIsInByb21pc2UiLCJudW1QYWdlcyIsImZ1bGxUZXh0IiwiaSIsInBhZ2UiLCJnZXRQYWdlIiwidGV4dENvbnRlbnQiLCJnZXRUZXh0Q29udGVudCIsInBhZ2VUZXh0IiwiaXRlbXMiLCJtYXAiLCJpdGVtIiwic3RyIiwiam9pbiIsInRleHRMZW5ndGgiLCJ0b3RhbFRleHRMZW5ndGgiLCJtZXNzYWdlIiwiY29kZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJFcnJvciIsInBhcnNlQ0FTVGV4dCIsInRleHQiLCJmdW5kcyIsInRvdGFsVmFsdWUiLCJ0b3RhbEludmVzdGVkIiwiZnVuZFBhdHRlcm4iLCJmb2xpb19wYXR0ZXJuIiwiYW1jX3BhdHRlcm4iLCJsaW5lcyIsInNwbGl0IiwibGluZSIsIm1hdGNoIiwibmFtZU1hdGNoIiwidHJpbSIsInBsYW5NYXRjaCIsInBsYW5UeXBlIiwidmFsdWVNYXRjaCIsImN1cnJlbnRWYWx1ZSIsInBhcnNlRmxvYXQiLCJyZXBsYWNlIiwiaW52ZXN0ZWRBbW91bnQiLCJmb2xpb01hdGNoIiwic2xpY2UiLCJNYXRoIiwibWF4IiwicmV2ZXJzZSIsImZpbmQiLCJsIiwiZm9saW8iLCJzdWJzdHJpbmciLCJhbWNNYXRjaCIsImFtYyIsInB1c2giLCJ2YWx1ZSIsImludmVzdGVkIiwiZSIsInBhcnNlQ0FTRmlsZSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZnVuZHNDb3VudCIsImVuZFRpbWUiLCJkdXJhdGlvbiIsInRvRml4ZWQiLCJ0b0xvY2FsZVN0cmluZyIsImlzRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/pdfParser.ts\n"));

/***/ })

});